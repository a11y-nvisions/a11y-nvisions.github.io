{"version":3,"sources":["Layers.js","menu.js","App.js","serviceWorker.js","index.js"],"names":["MenuLayer","children","layer","document","getElementById","ReactDOM","createPortal","MenuControllerContext","React","createContext","MenuBox","useContext","toggleState","isOpen","MenuExit","isVisible","MenuEntrance","useRef","useEffect","root","menu","focusable","querySelectorAll","filter","el","hasAttribute","length","firstEl","lastEl","addEventListener","e","key","shiftKey","preventDefault","focus","setTimeout","current","setAttribute","id","className","aria-label","map","idx","href","ref","onClick","MenuController","useState","setOpen","setVisible","Provider","value","aria-haspopup","App","isButtonCatched","setCatched","aria-labelledby","onBlur","aria-describedby","class","aria-hidden","Boolean","window","location","hostname","match","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.a746cf4f.chunk.js","sourcesContent":["import ReactDOM from 'react-dom' // React-dom을 불러옵니다. CRA로 만든 프로젝트에 기본적으로 깔려있습니다.\r\n\r\nexport const MenuLayer = ({children}) =>{  /* \r\n    MenuLayer Portal을 만들고 파라미터 필드에 객체 형태로 props.children을 불러옵니다.\r\n    Portal은 root와 분리된 또다른 최상위 div에 컴포넌트를 렌더링할 때 사용하는 기능입니다.*/\r\n    const layer = document.getElementById('menuLayer');/*레이어로 사용할 div의 아이디를 정해줍니다.\r\n    저는 단순하게 menuLayer로 하겠습니다. */\r\n    return ReactDOM.createPortal(children,layer)/*\r\n    아까 파라미터로 불러온 props.children을 첫 번째 인자로\r\n    위에서 const 상수로 넣어둔 menuLayer div를 두 번째 인자로 넣어줍니다.\r\n    */\r\n}","import React, {useState,useContext,useRef, useEffect} from 'react';\r\nimport * as Layers from './Layers';\r\nconst MenuControllerContext = React.createContext();\r\n\r\nconst MenuController = ()=>{\r\n    \r\n    const [isOpen,setOpen] = useState(null);\r\n    const [isVisible,setVisible]=useState(false);\r\n\r\n    const MenuExit = useRef();\r\n\r\n    const toggleState = () => {\r\n        setOpen(!isOpen);\r\n        setVisible(!isOpen)\r\n    }\r\n\r\n\r\n    return (\r\n        <MenuControllerContext.Provider  value={\r\n            {toggleState,isOpen,MenuExit,isVisible}}>\r\n            <button aria-label=\"메뉴 보기\" ref={MenuExit} onClick={toggleState} aria-haspopup={!isOpen} id=\"btnOpenMenu\">\r\n                <span className=\"material-icons md-auto\">menu</span>\r\n            </button>\r\n            <Layers.MenuLayer>\r\n                <MenuBox></MenuBox>\r\n            </Layers.MenuLayer>\r\n        </MenuControllerContext.Provider>\r\n    )\r\n}\r\n\r\nconst MenuBox = ()=>{\r\n    const {toggleState,isOpen,MenuExit,isVisible} = useContext(MenuControllerContext);\r\n    const MenuEntrance = useRef();\r\n\r\n    const menuitems=[\r\n        'Hello, NULI',\r\n        'Hello, Javascript',\r\n        'Hello, React'        \r\n    ]\r\n\r\n    useEffect(()=>{\r\n        const root = document.getElementById('root');//1. 있다가 사용합니다 미리 선언해요.\r\n        const menu = document.getElementById('menuLayer');//2. 초점을 가진 요소르 검색하기 위해 변수에 메뉴 영역을 담습니다.\r\n        const focusable = [...menu.querySelectorAll(\r\n        'a, button, input, textarea, select, details, [tabindex]:not([tabindex=\"-1\"])'\r\n        )].filter(el => !el.hasAttribute('disabled'));/*3. 메뉴 내에서 초점을 받을 수 있는 요소를 배열로 담고,\r\n         disabled된 요소를 필터로 걸러서 저장합니다.*/\r\n        const [firstEl,lastEl] = [focusable[0],focusable[focusable.length-1]];\r\n        /*3-1 포커스를 못 나가게 막을 요소를 각각 저장합니다. */\r\n\r\n        if(isOpen){\r\n            \r\n            /*3-2. 포커스를 가두는 이벤트들을 작성합시다. */\r\n            firstEl.addEventListener('keydown',function(e){\r\n                if(e.key === \"Tab\" && e.shiftKey ){\r\n                    e.preventDefault();\r\n                    lastEl.focus();\r\n                }\r\n            })/* 3-2-1. FirstEl에 초점이 있는 상태로 Tab 키와 Shift를 같이 누르면 기본 초점이동을 막고,\r\n             lastEl 친구에게로 초점을 보내게끔 합니다. */\r\n            lastEl.addEventListener('keydown',function(e){\r\n                if(e.key === \"Tab\" && !e.shiftKey ){\r\n                    e.preventDefault();\r\n                    firstEl.focus();\r\n                }\r\n            })/* 3-2-2. 마찬가지로 Tab키만 눌렀을 때 기본 초점이동을 막고,\r\n            firstEl 친구에게로 초점을 보냅니다. */\r\n\r\n            //4. 아까 root이라는 이름으로 지정해둔 #root을 활용하여, 스크린리더의 가상커서를 막아줍시다.\r\n            setTimeout(()=>MenuEntrance.current.focus(),100)\r\n            root.setAttribute('aria-hidden',true);//4-1. isOpen이 true면 aria-hidden이 활성화되어 가상커서의 탐색키를 막습니다.\r\n        }else if(isOpen === false){\r\n            root.setAttribute('aria-hidden',false);//4-2. isOpen이 false면 마찬가지로 aria-hidden을 해제하여 가상커서 탐색키를 사용하도록 합니다.\r\n            setTimeout(()=>MenuExit.current.focus(),100);\r\n        }\r\n    },[isOpen,MenuExit,MenuEntrance])\r\n    \r\n    return (\r\n    <div id=\"menu-wrapper\" className={\"global-menu isOpen \"+isVisible}>\r\n        <nav aria-label=\"콘텐츠 메뉴\">\r\n            <ul>\r\n                {menuitems.map((el,idx)=>{\r\n                    if(idx === 0){\r\n                        return <li key={idx}><a href=\"#\" ref={MenuEntrance}>{el}</a></li>\r\n                    }\r\n                    return <li key={idx}><a href=\"#\">{el}</a></li>\r\n                })}\r\n            </ul>\r\n        </nav>\r\n        <button aria-label={'닫기'} onClick={toggleState} id=\"btnCloseMenu\"><span className=\"material-icons\">close</span></button>\r\n    </div>\r\n    )    \r\n}\r\nexport default MenuController;","import React, {useState} from 'react';\nimport './App.css';\nimport MenuController from './menu'\nfunction App() {\n  const [isButtonCatched,setCatched] = useState(false)\n  const buttonMessage = ()=>{\n    const text = !isButtonCatched ? \n      (<span id={'joking-label'}>Tab키야 나 잡아봐라 <span class=\"visuallyhidden\">메롱</span><span aria-hidden={true}>&gt;👅&lt;</span></span>)\n    : (<span id={'joking-label'}>안돼! Tab키한테 잡혔어! ㅠㅠ..</span>)\n    return text;\n  }\n  const catchButton = (e)=>{\n    setCatched(true);\n  }\n  const letGoButton = (e)=>{\n    setCatched(false);\n  }\n\n  return (\n    <div className=\"App\">\n      {/* //Header 막대를 만들고, 아까 만든 컴포넌트와 대제목을 넣어줍시다. */}\n      <header>\n        <MenuController />\n        <h1>React A11y Hamburger Menu</h1>\n      </header>\n      <main>\n        <button aria-labelledby={'joking-label'} onBlur={letGoButton} aria-describedby='clickMe' onClick={catchButton} id={'catchMe'}>{buttonMessage()}<span id=\"clickMe\" className={'desc'}>잡았다면 클릭해주세요!</span></button>\n      </main>\n    </div>\n  );\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}