{"version":3,"sources":["menuList.js","menuLayer.js","hamburger-menu.js","App.js","serviceWorker.js","index.js"],"names":["MenuList","MenuContext","Consumer","closeMenu","stateClass","isMenuHide","aria-hidden","id","className","onClick","aria-label","MenuLayer","children","el","document","getElementById","ReactDOM","createPortal","React","createContext","Menu","props","useState","open","setOpen","setStateClass","undefined","setMenuHide","focusElement","createRef","toggleMenuHide","v","setRootHide","setFocusRef","focusCurrentRef","element","focus","Element","prototype","getFocusableElement","focusable","this","querySelectorAll","preventFocus","length","tabIndex","useEffect","root","querySelector","MenuFocusableChild","RootFocusableChild","Provider","value","aria-haspopup","App","isRootHide","Boolean","window","location","hostname","match","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"qRA2BeA,MAvBf,WACI,OACI,kBAACC,EAAYC,SAAb,MACK,YAAsC,IAApCC,EAAmC,EAAnCA,UAAUC,EAAyB,EAAzBA,WAAWC,EAAc,EAAdA,WACpB,OACA,qCAAKC,cAAaD,EAAYE,GAAG,cAAcC,UAAW,eAAeJ,GAAzE,cAAkGC,GAC9F,4BAAQE,GAAG,eAAeE,QAASN,EAAWO,aAAW,yCAAU,0BAAMF,UAAU,0BAAhB,UACnE,yBAAKA,UAAU,eACX,4BACI,4BAAI,2CACJ,4BAAI,2CACJ,4BAAI,2CACJ,4BAAI,kDCVjBG,EALG,SAAC,GAAe,IAAdC,EAAa,EAAbA,SACVC,EAAKC,SAASC,eAAe,aACnC,OAAOC,IAASC,aAAaL,EAASC,ICA7BZ,EAAciB,IAAMC,cAAc,MAmFhCC,MAjFf,SAAeC,GAAO,MAEKC,qBAFL,mBAEXC,EAFW,KAENC,EAFM,OAGiBF,mBAAS,UAH1B,mBAGXlB,EAHW,KAGAqB,EAHA,OAIeH,wBAASI,GAJxB,mBAIXrB,EAJW,KAIAsB,EAJA,KAMdC,EAAeC,sBAEbC,EAAiB,SAACC,GAChBJ,IAAJI,QAAoCL,IAWlCvB,EAAY,WACdqB,GAAQ,GACRH,EAAMW,iBAAYN,GAClBI,IACAL,EAAc,UACdQ,EAAYnB,SAASC,eAAe,YACpCmB,KAGED,EAAc,SAACE,GACjBP,EAAeO,GAGbD,EAAkB,WACpBN,EAAaQ,SAqCjB,OAlCAC,QAAQC,UAAUC,oBAAsB,WAEpC,MAAO,CACHC,UAFYC,KAEMC,iBAAiB,4EACnCC,aAAa,SAASZ,GAClB,IAAK,IAAIlB,EAAK,EAAGA,EAAK4B,KAAKD,UAAUI,OAAQ/B,IAAM,CAC/C,GAAGkB,EACiBU,KAAKD,UAAU3B,GACvBgC,UAAY,OAEJJ,KAAKD,UAAU3B,GACvBgC,SAAW,OAOvCC,qBAAU,WAEN,IAAMC,EAAOjC,SAASkC,cAAc,SAE9BC,EADYnC,SAASkC,cAAc,cACJT,sBAC/BW,EAAqBH,EAAKR,sBAC7BhB,GACC0B,EAAmBN,cAAa,GAAQO,EAAmBP,cAAa,IAClEpB,IACN0B,EAAmBN,cAAa,GAAOO,EAAmBP,cAAa,MAG7E,CAACpB,IAKC,kBAACtB,EAAYkD,SAAb,CAAsBC,MAAO,CAACjD,YAAUoB,OAAKnB,aAAWC,aAAW6B,oBAC/D,4BAAQzB,QA7DC,WACbe,GAAQ,GACRH,EAAMW,aAAY,GAClBF,IACAL,EAAc,UACdQ,EAAYnB,SAASC,eAAe,iBACpCmB,KAuD+B3B,GAAG,UAAU8C,iBAAe,EAAM3C,aAAW,4BAAQF,UAAU,sBAAqB,0BAAMA,UAAU,0BAAhB,SAC/G,kBAAC,EAAD,KACI,kBAAC,EAAD,CAAUL,UAAWA,OC5DtBmD,MAhBf,WAAgB,IAAD,EACoBhC,wBAASI,GAD7B,mBACN6B,EADM,KACKvB,EADL,KAGb,OACI,yBAAKxB,UAAU,MAAMF,cAAaiD,GAChC,gCACE,kBAAC,EAAD,CAAMvB,YAAaA,IACnB,sDAEF,8BACE,yDCFUwB,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZN5C,IAAS6C,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFhD,SAASC,eAAe,SDyHpB,kBAAmBgD,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,c","file":"static/js/main.c0ab4b04.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nimport {MenuContext} from './hamburger-menu'\r\n\r\nfunction MenuList(){\r\n    return (\r\n        <MenuContext.Consumer>\r\n            {({closeMenu,stateClass,isMenuHide})=>{\r\n                return (\r\n                <nav aria-hidden={isMenuHide} id=\"global-menu\" className={\"global-menu \"+stateClass} aria-hidden={isMenuHide}>\r\n                    <button id=\"btnCloseMenu\" onClick={closeMenu} aria-label=\"전체메뉴 닫기\"><span className=\"material-icons md-auto\">close</span></button>\r\n                    <div className=\"nav-wrapper\">\r\n                        <ul>\r\n                            <li><button>Menu 1</button></li>\r\n                            <li><button>Menu 2</button></li>\r\n                            <li><button>Menu 3</button></li>\r\n                            <li><button>Menu 4</button></li>\r\n                        </ul>\r\n                    </div>\r\n                </nav>\r\n                )\r\n            }}\r\n        </MenuContext.Consumer>\r\n        \r\n    )\r\n}\r\n\r\nexport default MenuList;","import ReactDOM from 'react-dom'\r\nconst MenuLayer = ({children}) =>{\r\n    const el = document.getElementById('gnb-layer');\r\n    return ReactDOM.createPortal(children,el);\r\n}\r\n\r\nexport default MenuLayer;","import React, { useState, useEffect, createRef } from 'react';\r\nimport MenuList from './menuList';\r\nimport MenuLayerPortal from './menuLayer';\r\nexport const MenuContext = React.createContext(null);\r\n\r\nfunction Menu (props) {\r\n    //class의 state들\r\n    const [open,setOpen] = useState();    \r\n    const [stateClass,setStateClass] = useState('closed');\r\n    const [isMenuHide,setMenuHide] = useState(undefined)\r\n    //초점관리용 ref\r\n    let focusElement = createRef();\r\n\r\n    const toggleMenuHide = (v)=>{\r\n        v ? setMenuHide(true) : setMenuHide(undefined);\r\n    }\r\n\r\n    const openMenu = () => {\r\n        setOpen(true);\r\n        props.setRootHide(true)\r\n        toggleMenuHide()\r\n        setStateClass('opened')\r\n        setFocusRef(document.getElementById('btnCloseMenu'));\r\n        focusCurrentRef();\r\n    }\r\n    const closeMenu = () => {\r\n        setOpen(false);\r\n        props.setRootHide(undefined)\r\n        toggleMenuHide()\r\n        setStateClass('closed')\r\n        setFocusRef(document.getElementById('btnMenu'));\r\n        focusCurrentRef();\r\n    }\r\n\r\n    const setFocusRef = (element)=>{\r\n        focusElement = element;\r\n    }\r\n\r\n    const focusCurrentRef = ()=>{\r\n        focusElement.focus();\r\n    }\r\n\r\n    Element.prototype.getFocusableElement = function() {//컨테이너 내의 키보드 초점을 갖는 요소 리스트를 얻는 메소드를 등록합니다.\r\n        const element = this;\r\n        return {\r\n            focusable:element.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'),\r\n            preventFocus:function(v){\r\n                for (let el = 0; el < this.focusable.length; el++) {\r\n                    if(v){\r\n                        const element = this.focusable[el];\r\n                        element.tabIndex = -1;\r\n                    }else{\r\n                        const element = this.focusable[el];\r\n                        element.tabIndex = ''\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    useEffect(()=>{\r\n        \r\n        const root = document.querySelector('#root');\r\n        const MenuLayer = document.querySelector('#gnb-layer');\r\n        const MenuFocusableChild = MenuLayer.getFocusableElement();\r\n        const RootFocusableChild = root.getFocusableElement();\r\n        if(open){\r\n            MenuFocusableChild.preventFocus(false); RootFocusableChild.preventFocus(true);\r\n        }else if(!open){\r\n            MenuFocusableChild.preventFocus(true); RootFocusableChild.preventFocus(false);\r\n        }\r\n\r\n    },[open])\r\n    \r\n    \r\n    \r\n    return (\r\n        <MenuContext.Provider value={{closeMenu,open,stateClass,isMenuHide,focusCurrentRef}}>\r\n            <button onClick={openMenu} id=\"btnMenu\" aria-haspopup={true} aria-label=\"메뉴 열기\" className=\"btn-hamburger-menu\"><span className=\"material-icons md-auto\">menu</span></button>\r\n            <MenuLayerPortal>\r\n                <MenuList closeMenu={closeMenu}></MenuList>\r\n            </MenuLayerPortal>\r\n        </MenuContext.Provider>\r\n    );\r\n};\r\n\r\nexport default Menu;","import React, {useState} from 'react';\nimport './App.css'\nimport Menu from './hamburger-menu';\n\nfunction App() {\n  const [isRootHide,setRootHide] = useState(undefined);\n\n  return (\n      <div className=\"App\" aria-hidden={isRootHide}>\n        <header>\n          <Menu setRootHide={setRootHide}></Menu>\n          <h1>Making hamburger Menu</h1>\n        </header>\n        <main>\n          <button>for FocusTrap Test</button>\n        </main>\n      </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}